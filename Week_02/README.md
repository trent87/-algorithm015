学习笔记

本周的主要学习内容是二维数据结构，包括：  
* Map和Set  
* 树、二叉树、二叉搜索树
* 堆和二叉堆  
* 图  

# Map和Set  
基于Hash表实现，通过hash函数将key映射到一个数组的index，hash表需要解决hash冲突，简单分析了Java中的HashMap，详见[HashMap小结](HashMap小结.md)。
Set基于HashTable实现
# 树、二叉树、二叉搜索树
由list引出了树的概念，当从一个节点有多个指针指向多个节点就会形成<font color='red'>树</font>。树结构的几个关键定义：根节点、父亲节点、左子树、右子树、叶子节点以及树的层数。
一个树如果只有左子树和右子树则为<font color='red'>二叉树</font>，而左子树的所有节点值均小于它的根节点且右子树上所有节点的值均大于根节点的二叉树为<font color='red'>二叉搜索树</font>
树的几个重要操作：遍历（前、中、后）,其中二叉搜索树的中序遍历是升序遍历。
二叉搜索的常规操作,包括插入、查询和删除的时间复杂度均为O(logn):  
* 二叉搜索树的查询操作类似于二分搜索；  
* 二叉搜索树的插入操作类似于查询操作，查询到的最后位置后直接插入；  
* 二叉搜索的删除操作：如果是叶子节点则直接删除，如果不是则取第一个大于被删除节点来代替当前节点。  
  
# 堆、二叉堆
堆的典型应用TOP-N。典型的堆基于<font color='red'>二叉堆</font>实现，工业实现中经常选择<font color='red'>斐波那契堆</font>。
二叉堆基本操作的时间复杂度:  
* findMax() O(1) 
* deleteMax()  O(logn)
* insert()  O(logn) （如果是斐波那契堆则可以到O(1))  

二叉堆满足的条件：  
* 通过完全二叉树实现  
* 树中任意根节点值>=子节点值  

由于是完全二叉树，可以用数组来存储数据，对于index=i的节点，左孩子的index为2\*i+1,右孩子的节点index为2\*i+2;对于index=i的节点，其父节点的index为floor((i-1)/2) 其中i=0为根节点。
具体操作：  
* insert操作：先插尾部；再与父亲节点进行大小比较，如大于则交换  
* delete max操作：将堆尾元素替换顶部；从堆顶依次向下调整整个堆（与较大的子节点进行交换）  
